<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Clipping Planes Demo - Cross-Section View</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        body,
        html {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
        }

        #toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            padding: 15px;
            background: rgba(30, 30, 30, 0.85);
            backdrop-filter: blur(10px);
            color: #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }

        p {
            font-size: 0.9rem;
            margin-bottom: 15px;
            color: #ccc;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .switch-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
        }

        .status {
            font-size: 0.8em;
            color: #888;
            margin-top: 10px;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #4CAF50;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="cesiumContainer"></div>

    <div id="toolbar">
        <a href="index.html" class="back-link">← Back to Main Demo</a>
        <h2>Clipping Planes Demo</h2>
        <p>Cross-Section & Underground View</p>

        <div class="control-group">
            <label class="switch-label">
                <input type="checkbox" id="toggleClipping">
                <span>Enable Cross-Section (Clipping Planes)</span>
            </label>
            <p style="font-size: 0.85rem; color: #aaa; margin-top: 5px;">
                Cuts away terrain to reveal underground pipes. Pipes are only visible when clipping is enabled.
            </p>
        </div>

        <div class="control-group">
            <label>Clipping Area Size (meters)</label>
            <div class="slider-container">
                <span>50m</span>
                <input type="range" id="clippingSize" min="50" max="500" value="200" step="50">
                <span>500m</span>
            </div>
        </div>

        <div class="status" id="statusText">Loading...</div>
    </div>

    <script>
        // Cesium Setup
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmNmNiNGMzYi00Y2U4LTQ4ZDYtYTFjOC05NjY0MDZlMzRlNTMiLCJpZCI6MzY4MDAwLCJpYXQiOjE3NjUyNzc1OTB9.7YpgEtFgQ5_Faib4dt4cr8eHM95CX-tmk_KQ1sT71Aw';

        // Setup Imagery Provider
        const imageryProvider = new Cesium.UrlTemplateImageryProvider({
            url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
            credit: 'Map data © OpenStreetMap contributors',
            maximumLevel: 19
        });

        const viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: false,
            skyBox: false,
            skyAtmosphere: false,
            contextOptions: {
                webgl: {
                    alpha: true
                }
            },
            animation: false,
            timeline: false,
            geocoder: true,
            homeButton: true,
            sceneModePicker: true,
            navigationHelpButton: true,
            infoBox: true,
            selectionIndicator: true
        });

        // Remove default imagery layer and add our OpenStreetMap layer
        viewer.scene.imageryLayers.removeAll();
        viewer.scene.imageryLayers.addImageryProvider(imageryProvider);

        // Default Background
        viewer.scene.backgroundColor = Cesium.Color.fromCssColorString('#222222');
        viewer.scene.globe.show = true;
        viewer.scene.globe.enableLighting = false;
        // Enable depth testing so terrain occludes pipes outside clipped region
        viewer.scene.globe.depthTestAgainstTerrain = true;

        // Remove default double-click lock on entity
        viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

        // Setup Camera for Amsterdam Havenstad
        const startCoordinates = {
            longitude: 4.878,
            latitude: 52.400,
            height: 1200,
            heading: 0,
            pitch: -Cesium.Math.toRadians(60)
        };

        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(
                startCoordinates.longitude,
                startCoordinates.latitude,
                startCoordinates.height
            ),
            orientation: {
                heading: Cesium.Math.toRadians(startCoordinates.heading),
                pitch: startCoordinates.pitch,
                roll: 0.0
            },
            duration: 3
        });

        // Enable underground camera movement
        viewer.scene.screenSpaceCameraController.enableCollisionDetection = false;

        // -- Clipping Planes for Cross-Section View --
        let clippingPlaneCollection = null;

        function updateClippingPlanesFromView(size) {
            // Get the center of the current view (where camera is looking)
            let center = viewer.camera.pickEllipsoid(
                new Cesium.Cartesian2(
                    viewer.canvas.clientWidth / 2,
                    viewer.canvas.clientHeight / 2
                )
            );

            if (!center) {
                // Fallback: use a point on the ground below the camera
                const cartographic = Cesium.Cartographic.fromCartesian(viewer.camera.position);
                cartographic.height = 0; // Ground level
                center = Cesium.Cartographic.toCartesian(cartographic);
            }

            // Remove existing clipping planes
            if (clippingPlaneCollection) {
                viewer.scene.globe.clippingPlanes = undefined;
                clippingPlaneCollection = null;
            }

            // Size in meters, half size for the square
            const halfSize = size / 2;

            // Create transform matrix at the center point (East-North-Up frame)
            const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);

            // Create four vertical planes that cut away everything outside the square
            // North plane: cuts everything north of center+halfSize
            const northPlane = new Cesium.ClippingPlane(
                new Cesium.Cartesian3(0, 1, 0), // Normal pointing north (in ENU frame)
                -halfSize // Negative distance keeps area south of this line
            );

            // South plane: cuts everything south of center-halfSize
            const southPlane = new Cesium.ClippingPlane(
                new Cesium.Cartesian3(0, -1, 0), // Normal pointing south
                -halfSize // Keeps area north of this line
            );

            // East plane: cuts everything east of center+halfSize
            const eastPlane = new Cesium.ClippingPlane(
                new Cesium.Cartesian3(1, 0, 0), // Normal pointing east
                -halfSize // Keeps area west of this line
            );

            // West plane: cuts everything west of center-halfSize
            const westPlane = new Cesium.ClippingPlane(
                new Cesium.Cartesian3(-1, 0, 0), // Normal pointing west
                -halfSize // Keeps area east of this line
            );

            clippingPlaneCollection = new Cesium.ClippingPlaneCollection({
                planes: [northPlane, southPlane, eastPlane, westPlane],
                modelMatrix: transform,
                unionClippingRegions: false // Use intersection - all planes must be satisfied
            });

            viewer.scene.globe.clippingPlanes = clippingPlaneCollection;
            
            // Return center cartographic for pipe filtering
            return Cesium.Cartographic.fromCartesian(center);
        }

        // Update pipe visibility based on clipping area
        function updatePipeVisibility(centerCarto, halfSizeMeters) {
            if (!centerCarto || !clippingEnabled) {
                // Hide all pipes if clipping is disabled
                pipeEntities.forEach(entity => {
                    entity.show = false;
                });
                return;
            }

            // Convert meters to degrees (approximation)
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = Math.cos(centerCarto.latitude) * metersPerDegreeLat;

            const dLat = halfSizeMeters / metersPerDegreeLat;
            const dLon = halfSizeMeters / metersPerDegreeLon;

            const minLat = centerCarto.latitude - dLat;
            const maxLat = centerCarto.latitude + dLat;
            const minLon = centerCarto.longitude - dLon;
            const maxLon = centerCarto.longitude + dLon;

            let visibleCount = 0;
            pipeEntities.forEach(entity => {
                const positions = entity._pipePositions;
                if (!positions || positions.length === 0) {
                    entity.show = false;
                    return;
                }
                
                // Check if any point of the pipe is within the clipping bounding box
                // OR if the pipe line segment intersects the bounding box
                let isVisible = false;
                
                // First, check if any point is inside
                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    if (pos.lon >= minLon && pos.lon <= maxLon &&
                        pos.lat >= minLat && pos.lat <= maxLat) {
                        isVisible = true;
                        break;
                    }
                }
                
                // If no point is inside, check if line segments intersect the box
                if (!isVisible) {
                    for (let i = 1; i < positions.length; i++) {
                        const prevPos = positions[i - 1];
                        const currPos = positions[i];
                        if (lineSegmentIntersectsBox(prevPos, currPos, minLon, maxLon, minLat, maxLat)) {
                            isVisible = true;
                            break;
                        }
                    }
                }
                
                // Only show if clipping is enabled AND pipe is in bounds
                entity.show = clippingEnabled && isVisible;
                if (entity.show) visibleCount++;
            });
            
            console.log(`Pipe visibility updated: ${visibleCount} visible out of ${pipeEntities.length}, bounds: [${minLon.toFixed(6)}, ${minLat.toFixed(6)}] to [${maxLon.toFixed(6)}, ${maxLat.toFixed(6)}]`);
        }
        
        // Helper function to check if line segment intersects bounding box
        function lineSegmentIntersectsBox(p1, p2, minLon, maxLon, minLat, maxLat) {
            // Check if either endpoint is inside
            if ((p1.lon >= minLon && p1.lon <= maxLon && p1.lat >= minLat && p1.lat <= maxLat) ||
                (p2.lon >= minLon && p2.lon <= maxLon && p2.lat >= minLat && p2.lat <= maxLat)) {
                return true;
            }
            
            // Check if line segment intersects any of the four edges of the bounding box
            // This is a simplified check - for more accuracy, use proper line-segment intersection
            const edges = [
                { x1: minLon, y1: minLat, x2: maxLon, y2: minLat }, // bottom
                { x1: maxLon, y1: minLat, x2: maxLon, y2: maxLat }, // right
                { x1: maxLon, y1: maxLat, x2: minLon, y2: maxLat }, // top
                { x1: minLon, y1: maxLat, x2: minLon, y2: minLat }  // left
            ];
            
            for (let edge of edges) {
                if (lineSegmentsIntersect(
                    p1.lon, p1.lat, p2.lon, p2.lat,
                    edge.x1, edge.y1, edge.x2, edge.y2
                )) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if two line segments intersect
        function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return false; // Parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        // -- Load Pipe Data --
        const pipeEntities = []; // Store all pipe entities to toggle visibility
        
        async function setupData() {
            try {
                // Load GeoJSON manually to have better control over coordinates
                const response = await fetch('stub_data.geojson');
                const geoJson = await response.json();

                // Create data source
                const dataSource = new Cesium.GeoJsonDataSource();

                // Process features manually to ensure Z coordinates are used
                for (let feature of geoJson.features) {
                    const type = feature.properties.type || 'Unknown';
                    const depth = feature.properties.depth || 0;

                    if (feature.geometry.type === 'LineString') {
                        // Create polyline entity with explicit height
                        const coordinates = feature.geometry.coordinates;
                        const positions = coordinates.map(coord => {
                            // coord is [lon, lat, z] or [lon, lat]
                            const lon = coord[0];
                            const lat = coord[1];
                            const z = coord.length > 2 ? coord[2] : depth; // Use Z from coord or depth from properties
                            return Cesium.Cartesian3.fromDegrees(lon, lat, z);
                        });

                        let color = Cesium.Color.ORANGE;
                        if (type === 'Sewer') color = Cesium.Color.DARKGREEN;
                        else if (type === 'Gas') color = Cesium.Color.YELLOW;
                        else if (type === 'Water') color = Cesium.Color.CYAN;
                        else if (type === 'Power') color = Cesium.Color.RED;

                        const entity = dataSource.entities.add({
                            polyline: {
                                positions: positions,
                                width: 10,
                                clampToGround: false,
                                arcType: Cesium.ArcType.GEODESIC,
                                material: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.6,
                                    color: color,
                                    taperPower: 1.0
                                }),
                                depthFailMaterial: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.5,
                                    color: color
                                })
                            },
                            properties: feature.properties,
                            show: false // Hide pipes by default - only show when clipping is active
                        });

                        // Store all positions for spatial filtering (check if pipe intersects clipping area)
                        // Store directly on entity, not in properties
                        entity._pipePositions = positions.map(pos => {
                            const carto = Cesium.Cartographic.fromCartesian(pos);
                            return {
                                lon: carto.longitude,
                                lat: carto.latitude
                            };
                        });
                        
                        pipeEntities.push(entity); // Store for toggling
                        const firstCarto = Cesium.Cartographic.fromCartesian(positions[0]);
                        console.log(`Pipe ${type} at depth ${depth}m, ${positions.length} points, first position:`, firstCarto);
                    } else if (feature.geometry.type === 'Polygon') {
                        // Handle buildings
                        const entity = dataSource.entities.add({
                            polygon: {
                                hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights(
                                    feature.geometry.coordinates[0].flat()
                                ),
                                extrudedHeight: feature.properties.height || 0,
                                material: Cesium.Color.fromCssColorString('#4682B4').withAlpha(0.9),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            },
                            properties: feature.properties
                        });
                    }
                }

                viewer.dataSources.add(dataSource);
                
                // Count pipes for status
                const pipeCount = geoJson.features.filter(f => f.geometry.type === 'LineString').length;
                document.getElementById('statusText').innerText = `Ready. ${pipeCount} pipes loaded. Enable clipping to see them underground.`;
                
                console.log(`Loaded ${pipeCount} pipes, ${dataSource.entities.values.length} total entities`);
            } catch (e) {
                console.error("Data failed:", e);
                document.getElementById('statusText').innerText = "Error loading data.";
            }
        }
        setupData();

        // -- Clipping Planes Controls --
        const toggleClipping = document.getElementById('toggleClipping');
        const clippingSizeSlider = document.getElementById('clippingSize');
        let clippingEnabled = false;

        function applyClipping() {
            if (clippingEnabled) {
                const size = parseInt(clippingSizeSlider.value);
                const halfSize = size / 2;
                const centerCarto = updateClippingPlanesFromView(size);
                
                // Update pipe visibility based on clipping area
                updatePipeVisibility(centerCarto, halfSize);
                
                const visibleCount = pipeEntities.filter(e => e.show).length;
                document.getElementById('statusText').innerText = `Clipping enabled (${size}m area) - ${visibleCount} pipes visible`;
            } else {
                // Disable clipping
                if (clippingPlaneCollection) {
                    viewer.scene.globe.clippingPlanes = undefined;
                    clippingPlaneCollection = null;
                }
                // Hide all pipes when clipping is disabled
                updatePipeVisibility(null, 0);
                document.getElementById('statusText').innerText = "Clipping disabled - Pipes hidden";
            }
        }

        toggleClipping.addEventListener('change', (e) => {
            clippingEnabled = e.target.checked;
            applyClipping();
        });

        clippingSizeSlider.addEventListener('input', (e) => {
            if (clippingEnabled) {
                const size = parseInt(e.target.value);
                const halfSize = size / 2;
                const centerCarto = updateClippingPlanesFromView(size);
                updatePipeVisibility(centerCarto, halfSize);
                
                const visibleCount = pipeEntities.filter(e => e.show).length;
                document.getElementById('statusText').innerText = `Clipping enabled (${size}m area) - ${visibleCount} pipes visible`;
            }
        });

        // Update clipping planes when camera moves
        viewer.camera.moveEnd.addEventListener(() => {
            if (clippingEnabled) {
                const size = parseInt(clippingSizeSlider.value);
                const halfSize = size / 2;
                const centerCarto = updateClippingPlanesFromView(size);
                updatePipeVisibility(centerCarto, halfSize);
            }
        });
    </script>
</body>

</html>

